load_lib "libgloss.exp"

#
# Run the test specified by srcfile and resultfile. compile_args and
# exec_args are additional arguments to be passed in when compiling and
# running the testcase, respectively.
#
proc test_libcwd { options srcfile compile_args inpfile resultfile exec_args } {
    global base_dir
    global LIBS OPTIONS
    global includes
    global srcdir subdir objdir
    global ld_library_path

verbose "Calling test_libcwd:"
verbose "    options = \"$options\""
verbose "    srcfile = \"$srcfile\""
verbose "    compile_args = \"$compile_args\""
verbose "    inpfile = \"$inpfile\""
verbose "    resultfile = \"$resultfile\""
verbose "    exec_args = \"$exec_args\""
verbose "    srcdir = \"$srcdir\""
verbose "    LIBS = \"$LIBS\""
verbose "    OPTIONS = \"$OPTIONS\""

    set args ""

    if { $compile_args != "" } {
	lappend args "additional_flags=$compile_args"
    }

    regsub "^(.*)/\[^/\]+$" "$srcfile" "\\1" path
    regsub "^.*/(\[^/.\]+)\[.\]\[^/.\]*$" "$srcfile" "\\1" out

verbose "    path = \"$path\""
verbose "    out = \"$out\""

    lappend args "libs=$LIBS"
    lappend args "additional_flags=$OPTIONS -I$path"
    lappend args "c++"

    set executable "${objdir}/$out"
    set errname "[file tail $srcfile]"
    if { $compile_args != "" } {
	set errname "$errname $compile_args"
    }

    if { [target_compile $srcfile "$executable" executable $args] != "" } {
	fail "$errname compilation"
	setup_xfail "*-*-*"
	fail "$errname execution"
	setup_xfail "*-*-*"
	fail "$errname output"
	return;
    }
    pass "$errname compilation"

    set result [libcwd_load $executable "$exec_args" "$inpfile"];
    set status [lindex $result 0];
    set output [lindex $result 1];
    $status "$errname execution"
    if { $status != "pass" } {
	setup_xfail "*-*-*"
	fail "$errname output"
	return;
    }

    regsub "\n*$" $output "" output
    verbose "resultfile is $resultfile"
    set resultid [open $resultfile r];
    set passed 1;
    set reline "^("
    append reline [gets $resultid];
    set done [eof $resultid];
    while { $done == 0 } {
      regsub "\n*$" $reline ")$" reline
      verbose "reline = \"$reline\""
      set index [string first "\n" $output];
      verbose "index = $index" 2
      if { $index == -1 } {
        set outline $output
	set output ""
      } else {
	set len [string length $output];
	verbose "len = $len" 2
	set outline [string range $output 0 [expr $index - 1]];
	set output [string range $output [expr $index + 1] end];
      }
      verbose "outline = \"$outline\""
      verbose "output is now \"$output\"" 2

      if {$options == "regexp_match"} {
	  if { [regexp -- $reline $outline] == 0 } {
	      clone_output "expected: \"$reline\""
	      clone_output "got     : \"$outline\""
	      set passed 0;
	      set done 1;
	  }
      } else {
	  if { $reline != $outline } {
	      clone_output "expected: \"$reline\""
	      clone_output "got     : \"$outline\""
	      set passed 0;
	      set done 1;
	  }
      }

      set reline "^("
      append reline [gets $resultid];
      if { $done == 0 } {
	set done [eof $resultid];
      }
    }
    if { $output != "" } {
      if { $passed == 1 } {
	clone_output "output left: \"$output\""
      }
      set passed 0;
    }
    if { $passed == 1 } {
	pass "$errname output"
    } else {
	fail "$errname output"
    }
    close $resultid;
}
