libcwd-0.99.10

	MAJOR CHANGE: malloc, calloc, realloc and free are no longer macros but are now
	declared as external "C" functions.  This means that *all* allocations done by
	an application are now being caught, including those done from libc, libstdc++
	and any other library that might be linked.

	Libcwd does not use libbfd anymore (and thus also libiberty).  The symbol table
	is now read by libcwd itself as is the source file and line number lookup.
	The configure option --disable-libcwd-bfd was therefore renamed to
	--disable-libcwd-location.  Added was the configure option --enable-libcwd-bfd
	in order to allow you to still use libbfd.

	The management of CWDEBUG has been made a bit clearer:  is not possible anymore
	to #include <libcw/debug.h> without defining CWDEBUG.  This to avoid confusion.

	For gurus only: Note that now it *is* possible to include <libcw/debugmalloc.h>
	directly, but only when CWDEBUG is *not* defined.  In that case you will need
	to include a special "nodebug.h" that leaves the memory allocation support
	intact.  For this stripped down functionality of libcwd a bug was fixed:
	set_alloc_checking_off() and set_alloc_checking_on() are now still functional
	in that case.  In case non-gurus are reading this: Those two functions are not
	documented on purpose, just forget you ever saw this paragraph.

	API changes:

	::libcw_bfd_builtin_return_address_offset was renamed to
	libcw::debug::builtin_return_address_offset.

	Two methods have been added to class libcw::debug::debug_ct: `inc_indent'
	and `dec_indent' to increment and decrement the indentation respectively.

	The following only applies when __libc_malloc could not be found.  Instead of
	using this you should really upgrade your libc.

	[ strdup(3) and wcsdup(3) are now treated like malloc(2), which means that
	  they are macros.  The default AllocTag used is "strdup()" and "wcsdup()"
	  respectively, but one can easily override that.  For example:
	    char* s = strdup("\e[31mHello\tWorld!\e[0m");
	    AllocTag_dynamic_description(a, "strdup: \"" << libcw::debug::buf2str(a, strlen(a)) << '"');
	  will print 'strdup: "\e[31mHello\tWorld!\e[0m"' as description.

	  Added a new macro: RegisterExternalAlloc(ptr).
	  This macro calls libcw::debug::register_external_allocation(ptr) unless
	  --disable-libcwd-alloc was used during configure; then the macro is empty.
	  This function allows one to register an external allocation so it can now
	  can be reallocated or freed by the application (as well as externally).
	  Magic numbers are not added because that would need a realloc (and thus
	  a pointer change) and it would break the case where the external library
	  would occasionally free the allocation again. ]

libcwd-0.99.9

	template<typename T> type_info_of<T>(void) was changed so that it no longer ignores
	any top-level qualifiers (in example, type_info_of<A const&>()); when using g++ 3.0.
        Note that 0.99.8 still ignored those (including a `const') despite the release notes
	saying it didn't.

	The signature of template<typename T> type_info_of<T>(T) has been changed into
	template<typename T> type_info_of<T const&> in order to allow it to be used for
	abstract objects and/or objects with protected constructors.  This also avoids
	that a copy constructor for type T is called.  This version of type_info_of
	*does* ignore the top-level qualifiers (just like typeid() does).

	demangle_type(char const* in, std::string& out) now can be passed a string `in' that
	is not zero terminated.  This allows to demangle types in the middle of a mangled
	name without first copying the type (which is often impossible because you don't know
	what the type is in the first place).

	A new demangler was added for g++-3.0 and higher (the new ABI).  This took me weeks
	and weeks of hard work!

	class channel_ct has a new method: initialize(char const* label).  This allows one
	to pre-initialize a debug channel in the emergency case that it is needed before
	the constructor of this global object is called.  All global objects that libcwd
	declares are initialized this way when either `libcw_do' is constructed, or at the
	first call to new/malloc.

libcwd-0.99.8

	This version now also compiles and works with g++ 2.95.3 and 3.0 20010523 (prerelease).
	Demangling of variables and types with g++ 3.0 is still not implemented however.

	As a result of how libstdc++-v3 works, I've been forced to make all allocations done
	inside Dout() `internal'.  This has as disadvantage that memory allocations that are
	allocated inside Dout (in the user program; for example: Dout(dc::foo, malloc(1)))  but
	never freed will leak memory unnoticed.  Freeing this memory later, outside Dout(),
	currently leads to the rather confusing error:

	  COREDUMP: Trying to delete[] a pointer (0x80525d8) that appears to be internally
	  allocated!  This might be a bug in libcwd.  The magic number diagnostic gives: You
	  are 'delete[]'-ing a pointer (0x80525d8) that was allocated with 'new[]' internally
	  by libcwd.  This might be a bug in libcwd.

	template<typename T> type_info_of<T>(void) was changed so that it no longer ignores a
	top-level `const' (in example, type_info_of<A const>()); except on g++ version 2.96
	(RedHat) which has a bug that causes this `const' still to be ignored.

	Several bugs were fixed that caused libcwd not to compile when the more exotic
	configure options, like --disable-*, were used.

libcwd-0.99.7

	This version compiles with g++ 3.0 20010224 (prerelease).  That is of
	little use however because it still doesn't work with libstdc++ version 3
	(some serious rewriting seems to be needed for that :().  Also note that
	this version is (still) not Thread-Safe.

	Removed the compile option "-fno-exceptions" as default,
	the library now also compiles without it.

	Removed libcw/h.h.  The library now does not include namespace std
	anymore by default and was patched to also compile in that case (this
	worked anyway already but is needed for g++-3.0).

	API changes:

	Support for the macro Dout_vform has been removed because ostream::vform
	isn't conforming the standard and is gone in libstdc++ version 3.

	libcw::debug::find was renamed to libcw::debug::find_channel.

	Bug fixes:

	g++-2.95.x core dumped in lockable_auto_ptr.h.  This is the reason
	for the release of 0.99.7.

	Improvements in acinclude.m4: some tests where done with the C++
	compiler and failed when using a compiler in a non standard place.
	Other tests failed because they use exit() without a proper proto-
	type.

	Fix in the testsuite so it also works when using a compiler that is
	installed in a non-standard place.  You still need to add the path to
	libstdc++-3.so to your LD_LIBRARY_PATH however!

libcwd-0.99.6

	A little gadget was added to namespace libcw::debug `cwprint_using'.
	This template function can be used to print objects to a debug
	stream using a method like `void print_on(ostream&) const'.
	Example usage: Dout(dc::notice, "object is: " <<
            cwprint_using(object, &Object::method) << '.');
        which then calls `void object.method(ostream&) const' to print data
	to the debug ostream.  When variations to this trick are needed
	then you can obviously add those to your local debug.h file.

	It is now allowed to use -DCWDEBUG instead of -DDEBUG while compiling
	files.  This allows to use the macro DEBUG for something else.  The
	use of -DDEBUG is deprecated, please switch to CWDEBUG.

	API changes:

	Major namespace changes:
	Almost everything was moved to namespace libcw::debug.
	This means that you probably will need to add a
	`using namespace libcw::debug;' to your local debug.h file.
	Note that namespace libcw::debug is automatically included in Debug()
	and Dout() et al; however due to a bug in the compiler this sometimes
	doesn't work and you still have to explicitely give a namespace.
	The following functions are still in global namespace when DEBUGMALLOC
	is defined:
	  __libcwd_malloc(unsigned int)
	  __libcwd_calloc(unsigned int, unsigned int)
	  __libcwd_realloc(void*, unsigned int)
	  __libcwd_free(void*)
	  template<typename T> T* __libcwd_allocCatcher<T>
	and it still redefines operators new and delete of course.
	The following templates are defined in namespace libcw:
	lockable_auto_ptr<>, manip1_tct<>, manip2_tct<>, imanip_id_tct<>,
	get_imanip_data<>, get_omanip_data<> and omanip_id_tct<>.
	These are defined in the header files libcw/lockable_auto_ptr.h and
	libcw/iomanip.h (they are actually part of libcw but also included
	with libcwd because libcwd uses them internally).
	[ Use "using namespace libcw::debug;" ]
	[ "lockable_auto_ptr"        --> "libcw::lockable_auto_ptr" ]

	The bfd interface has been redesigned:
	- The global structure `location_st' has been removed and is replaced
	  by a class `location_ct' (in namespace `libcw::debug', see above).
	- The function `libcw_bfd_pc_function_name' has been renamed to
	  `libcw::debug::pc_mangled_function_name'.
        - The function `libcw_bfd_pc_location' has been completely removed.
	  Instead you should use the constructor location_ct(void const* addr).
	If you used any of this then you will need to recompile your programs.
	There is no danger to make errors: things are garanteed to not compile
	until you fixed them except for the following changes in functionality
	of the function name pointer as returned by location_ct::function():
	- The function name pointer as returned by location_ct::mangled_function_name()
	  is now the same as what is returned by pc_mangled_function_name (This
	  makes it unnecessary to call pc_mangled_function_name after pc_location
	  failed, in the hope that that will work).
	- It is now possible to check if the function that is returned is known
	  by comparing the returned function name pointer with
	  `libcw::debug::unknown_function_c' (instead of needing a strcmp()).
	- `pc_mangled_function_name' also returns `libcw::debug::unknown_function_c'
	   on failure and not NULL as did `libcw_bfd_pc_function_name'.
	[ "location_st" --> "libcw::debug::location_ct"               ]
	[ "libcw_bfd_pc_function_name(addr)" -->
	               "libcw::debug::pc_mangled_function_name(addr)"
	               (and doesn't return NULL anymore)              ]
	[ "location_st location; libcw_bfd_pc_location(location, addr);" -->
	  "libcw::debug::location_ct location(addr);"                 ]
	[ Available interface of location_ct: see libcw/bfd.h         ]

	A few functions have been renamed now they were moved inside the
	libcw::debug namespace:
	The class debugmalloc_marker_ct was renamed to just marker_ct.
	The function libcw_debug_move_outside was renamed to move_outside.
	The function debug_mem_size was renamed to mem_size;
	The function debug_memblks was renamed to memblks;
	[ "debugmalloc_marker_ct"    --> "libcw::debug::marker_ct"    ]
	[ "libcw_debug_move_outside" --> "libcw::debug::move_outside" ]
	[ "debug_mem_size"           --> "libcw::debug::mem_size"     ]
	[ "debug_memblks"            --> "libcw::debug::memblks"      ]

	The macro ASSERT(x) no longer contains a ';', this might mean that you
	need to add semi-colons yourself if you have been using it.
	[ "ASSERT( i == 1 )"         --> "ASSERT( i == 1 );"          ]

	Bug fixes:

	Fixed demangling `const' member functions aka: void Foo::foo(void) const;

	There was 'static initialisation order fiasco' bug that appeared
	mainly on solaris (linux always first initializes the shared
	libraries and only then constructs global objects of the application).
	The bug occured in most cases when a memory allocation was done in the
	constructor of a global object while the global objects of libcwd were
	not initialized yet.  The main problem was that a debub object (libcw_do)
	was NOT turned off before initialisation.  This fix allows the use of
	malloc/new (of course), Dout and DoutFatal before libcwd is initialized.
	Other libcwd functions can cause a core dump when used in constructors
	of global objects.

libcwd-0.99.5

	The prototype of libcw_bfd_pc_location was changed from
	location_st libcw_bfd_pc_location(void const* addr) into
	void libcw_bfd_pc_location(location_st& result, void const* addr).

	Support for openBSD was finished: it is now possible to
	compile a static library.  Unfortunately, it is still not
	possible to compile a shared library on this OS.

	Writing "DoutFatal(error_cf, ..." is no longer allowed, it now
	is required to explicitely add the debug channel and write
	"DoutFatal(dc::fatal|error_cf, ...".

	Added support for libtool-1.3c and higher (cvs developer version).

	Bug fixes:

	Fixed a problem related to reentrance of bfd_find_nearest_line
	(of libbfd) under certain circumstances, causing a copy of
	uninitialized memory.

	Removed a few compile warnings for g++-2.96.

	The order of debug channels in a `ForAllDebugChannels' is no
	longer dependant of the order of initialisation of the global
	debug channel objects (they are now alphabetically ordered on
	label).

	Fixed the generation of nodebug.h in the example project to remove
	the replacement-lists too after turning #defines into #undef.

	Now using the namespace of std::type_info in libcw/type_info.h.

	Lots of bug fixes and additions in the demangler.

libcwd-0.99.4

	A real testsuite was added, based on dejagnu.

	We depend more on libtool now to handle linking with shared or
	static libraries.  As a result you can (again) on linux, link
	with just -lcwd (without having to specify also -lbfd -liberty).

	Bug fixes:

	A locked lockable_auto_ptr would still transfer ownership
	when using the assignment operator.  IMPORTANT: API change:
	now a locked lockable_auto_ptr does NOT transfer ownership
	when using the assignment operator (as was documented).

	Libcwd got into an endless loop when a fatal error occured
	before the fatal debug channels where initialized.  This
	happened for instance when a hard limit for the core size
	is set.

	When a hard limit for the core size is set, the call to
	setrlimit failed and libcwd terminated with a fatal
	error (and got into a loop, see above).  Now it sets the
	core size to the maximum value and prints a warning when
	that isn't unlimited.

libcwd-0.99.3

	A different bug work around for the compiler bug that surfaces
	in iomanip.h has been used.  It turned out that not only
	gcc-2.95.2 but even snap shot 2.96-20000724 has problems with
	the (ISO C++ correct) construct that was used.  The new
	work around works better and is not any longer dependend on the
	value of CXXFLAGS.

	Support for solaris has been added.  Tests were done on a 
	sparc-sun-solaris2.7.

	Configuration and installation has been improved on FreeBSD,
	it should now compile 'out of the box' with the usual
	"./configure; make; make install".
	
	It is not necessary to use GNU make any longer when using the
	tar ball distribution (GNU make is still needed if you use
	cvs or --enable-maintainer-mode).

libcwd-0.99.2

	Configuration is now automated, using autoconf.  This removes
	the need to install the prototype package.

	The Internal Compiler Error in debugmalloc.cc has been isolated
	and a workaround has been added.  Whether or not the workaround
	is needed is detected by ./configure (but be warned: it depends
	on the CXXFLAGS you use, this bug only occurs when using -ggdb).

	A new function `Debug( check_configuration() )' was added.  Use
	it to assure that the configuration of the linked library matches
	the configuration of the header files used.

	demangle.cc was completely rewritten.  It now exports two functions:
	`demangle_type' and `demangle_symbol', the latter is a replacement
	for the `cplus_demangle' from libiberty.  This allows to link with
	the shared version of libiberty (needed by libbfd) which was needed
	on FreeBSD.  This also gets rid of any direct dependence of libcwd
	on libiberty, which wasn't good because libiberty is not compiled
	with -fPIC.

libcwd-0.99.1

	Support for FreeBSD (4.0)
	Improved bfd.cc a little (lookup of symbols and source:line info)
	Minor bug fixes

libcwd-0.99.0

	First public release
