// @configure_input@
// $Header$
//
// Copyright (C) 2000, by
// 
// Carlo Wood, Run on IRC <carlo@alinoe.com>
// RSA-1024 0x624ACAD5 1997-01-26                    Sign & Encrypt
// Fingerprint16 = 32 EC A7 B6 AC DB 65 A6  F6 F6 55 DD 1C DC FF 61
//
// This file may be distributed under the terms of the Q Public License
// version 1.0 as appearing in the file LICENSE.QPL included in the
// packaging of this file.
//

#ifndef LIBCW_DEBUGGING_DEFS_H
#define LIBCW_DEBUGGING_DEFS_H

//
// DO NOT CHANGE THIS FILE
//
// The defines in this file are configuration options chosen during
// compilation of libcwd.  To change these option, run `configure'
// with the appropriate commandline options (Use `configure --help'
// for more details).  In order to be sure that a program is linking
// with a library that was compiled with the same header file, call
// Debug( check_configuration() ); at the top of your program.
//
// See http://libcw.sourceforge.net/debugging/
// for more, detailed documentation.
//

//
// DEBUGMALLOC
//
// Turn on debugging for memory (de-) allocation. This
// will warn you when you free an invalid block.
// It also enables Memory Leak Detection (See html documentation).

#@CW_CONFIG_DEBUGMALLOC@ DEBUGMALLOC

//
// DEBUGMAGICMALLOC
//
// Add a magic number to the beginning and the end of each
// allocated memory block, and check this when the block is
// deleted or reallocated.

#ifdef DEBUGMALLOC
#@CW_CONFIG_DEBUGMAGICMALLOC@ DEBUGMAGICMALLOC
#endif

//
// DEBUGUSEBFD
//
// Add BFD code.
//
// You will need libbfd.a and libiberty.a, which are part of GNU binutils.
//
// Turning this on causes libcwd to print source file and line
// number information about where memory was allocated in the
// memory allocation overview.
// It also provides an interface, allowing applications that link
// with libcwd to print debugging information using the symbol table.
//

#ifdef DEBUG
#@CW_CONFIG_DEBUGUSEBFD@ DEBUGUSEBFD
#endif

//
// DEBUGDEBUG
//
// Turns on a lot of extra debugging output concerning
// global declarations prior to the initialisation of the
// debug channels and concerning the 'alloc_list_ct'
// structure used in debugmalloc (if DEBUGMALLOC is
// defined). This will not be usefull to you unless
// you manage to let the program coredump even before
// it reaches main().
// An added feature: With this defined, your program passes
// debugdebugcheckpoint() every time you use the Dout()
// macro, this is intended to be used to find a point in the
// program close to an unknown bug (before main()), and thus
// before debugger watch points can be used).

#ifdef DEBUG
#@CW_CONFIG_DEBUGDEBUG@ DEBUGDEBUG
#endif

//
// DEBUGDEBUGMALLOC
//
// Turns on even more debug output: Internal memory allocations
// are written to cerr.  This is needed for debugging internal
// memory allocations which are done before libcw is initialized.
// (Example: On Solaris2.4 it turned out that at the termination
//  of the program, in exit(2), an invalid pointer was free-ed.
//  Defining DEBUGDEBUGMALLOC was needed to find out when this
//  memory block had been allocated, and what it was).

#ifdef DEBUGDEBUG
#@CW_CONFIG_DEBUGDEBUGMALLOC@ DEBUGDEBUGMALLOC
#endif

//
// DEBUGMARKER
//
// Adds support for `markers'.  Always leave defined.
//

#if defined(DEBUG) && defined(DEBUGMALLOC)
#@CW_CONFIG_DEBUGMARKER@ DEBUGMARKER
#endif

//
// Configuration signature
//

#ifdef DEBUG
namespace libcw {
  namespace debug {

extern unsigned long config_signature_lib;
static unsigned long const config_signature_header = (0
#ifdef DEBUGMALLOC
	|1
#endif
#ifdef DEBUGMAGICMALLOC
	|2
#endif
#ifdef DEBUGUSEBFD
	|4
#endif
#ifdef DEBUGDEBUG
	|8
#endif
#ifdef DEBUGDEBUGMALLOC
	|16
#endif
#ifdef DEBUGMARKER
	|32
#endif
	);
extern void conf_check_failed(void);
inline void check_configuration(void) {
  if (config_signature_lib != config_signature_header)
    conf_check_failed();
}

  } // namespace debug
} // namespace libcw
#endif // DEBUG

#endif // LIBCW_DEBUGGING_DEFS_H
