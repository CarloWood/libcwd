// @configure_input@
// $Header$
//
// Copyright (C) 2000, by
// 
// Carlo Wood, Run on IRC <carlo@alinoe.com>
// RSA-1024 0x624ACAD5 1997-01-26                    Sign & Encrypt
// Fingerprint16 = 32 EC A7 B6 AC DB 65 A6  F6 F6 55 DD 1C DC FF 61
//
// This file may be distributed under the terms of the Q Public License
// version 1.0 as appearing in the file LICENSE.QPL included in the
// packaging of this file.
//

#ifndef LIBCW_DEBUGGING_DEFS_H
#define LIBCW_DEBUGGING_DEFS_H

//
// DO NOT CHANGE THIS FILE
//
// The defines in this file are configuration options chosen during
// compilation of libcwd.  To change these option, run `configure'
// with the appropriate commandline options (Use `configure --help'
// for more details).  In order to be sure that a program is linking
// with a library that was compiled with the same header file, call
// Debug( check_configuration() ); at the top of your program.
//
// See http://libcw.sourceforge.net/debugging/
// for more, detailed documentation.
//

// Allow people to use just -DDEBUG instead of -DCWDEBUG in the command line.
#if defined(DEBUG) && (DEBUG == 1)
#define CWDEBUG
#endif

//
// DEBUGMALLOC
//
// Turn on debugging for memory (de-) allocation. This
// will warn you when you free an invalid block.
// It also enables Memory Leak Detection (See html documentation).

#@CW_CONFIG_DEBUGMALLOC@ DEBUGMALLOC

//
// DEBUGMAGICMALLOC
//
// Add a magic number to the beginning and the end of each
// allocated memory block, and check this when the block is
// deleted or reallocated.

#ifdef DEBUGMALLOC
#@CW_CONFIG_DEBUGMAGICMALLOC@ DEBUGMAGICMALLOC
#endif

//
// DEBUGUSEBFD
//
// Add BFD code.
//
// Turning this on causes libcwd to print source file and line
// number information about where memory was allocated in the
// memory allocation overview.
// It also provides an interface, allowing applications that link
// with libcwd to print debugging information using the symbol table.
//

#ifdef CWDEBUG
#@CW_CONFIG_DEBUGUSEBFD@ DEBUGUSEBFD
#endif

//
// DEBUGUSEGNULIBBFD
//
// If you don't have an ELF32 system then you might need this.  You will need
// libbfd.a and libiberty.a, which are part of GNU binutils.
//
// If you use this then you are not allowed to distribute the resulting executables
// because the GPL of libbfd prohibbits distribution of code that is not GPL-ed
// and the resulting executable will be partly QPL-ed (this is a restriction of
// the GPL not the QPL).  Note that if you have an ELF system (like linux) then you
// DON'T need this.
//
// Note that if you want to release *your* program under the GNU GPL, and still link
// with libcwd (and distribute the resulting binaries) then you can easily do that.
// You can resolve the legal conflict for your program by adding a notice like this
// to it: 
//
//     As a special exception, you have permission to link this program
//     with the libcwd library and distribute executables, as long as you
//     follow the requirements of the GNU GPL in regard to all of the
//     software in the executable aside from libcwd.
//
// You can do this, legally, if you are the copyright holder for the program.
// Add it in the source files, after the notice that says the program is covered
// by the GNU GPL.  [ Source: http://www.gnu.org/philosophy/license-list.html
// section "The Qt Public License (QPL)." ].
//

#ifdef DEBUGUSEBFD
#@CW_CONFIG_DEBUGUSEGNULIBBFD@ DEBUGUSEGNULIBBFD
#endif

//
// DEBUGDEBUG
//
// Turns on a lot of extra debugging output concerning
// global declarations prior to the initialisation of the
// debug channels and concerning the 'alloc_list_ct'
// structure used in debugmalloc (if DEBUGMALLOC is
// defined). This will not be usefull to you unless
// you manage to let the program coredump even before
// it reaches main().
// An added feature: With this defined, your program passes
// debugdebugcheckpoint() every time you use the Dout()
// macro, this is intended to be used to find a point in the
// program close to an unknown bug (before main()), and thus
// before debugger watch points can be used).

#ifdef CWDEBUG
#@CW_CONFIG_DEBUGDEBUG@ DEBUGDEBUG
#endif

//
// DEBUGDEBUGMALLOC
//
// Turns on even more debug output: Internal memory allocations
// are written to cerr.  This is needed for debugging internal
// memory allocations which are done before libcw is initialized.
// (Example: On Solaris2.4 it turned out that at the termination
//  of the program, in exit(2), an invalid pointer was free-ed.
//  Defining DEBUGDEBUGMALLOC was needed to find out when this
//  memory block had been allocated, and what it was).

#ifdef DEBUGDEBUG
#@CW_CONFIG_DEBUGDEBUGMALLOC@ DEBUGDEBUGMALLOC
#endif

//
// DEBUGMARKER
//
// Adds support for `markers'.  Always leave defined.
//

#if defined(CWDEBUG) && defined(DEBUGMALLOC)
#@CW_CONFIG_DEBUGMARKER@ DEBUGMARKER
#endif

//
// Configuration signature
//

#ifdef CWDEBUG
namespace libcw {
  namespace debug {

extern unsigned long config_signature_lib;
static unsigned long const config_signature_header = (0
#ifdef DEBUGMALLOC
	|1
#endif
#ifdef DEBUGMAGICMALLOC
	|2
#endif
#ifdef DEBUGUSEBFD
	|4
#endif
#ifdef DEBUGUSEGNULIBBFD
	|8
#endif
#ifdef DEBUGDEBUG
	|16
#endif
#ifdef DEBUGDEBUGMALLOC
	|32
#endif
#ifdef DEBUGMARKER
	|64
#endif
	);
extern void conf_check_failed(void);
inline void check_configuration(void) {
  if (config_signature_lib != config_signature_header)
    conf_check_failed();
}

  } // namespace debug
} // namespace libcw
#endif // CWDEBUG

//
// autoconf defines that are needed.
//

#ifdef DEBUGMALLOC
#@CW_CONFIG_HAVE___LIBC_MALLOC@ DEBUGMALLOCEXTERNALCLINKAGE
#endif

#ifdef DEBUGUSEBFD
#@CW_CONFIG_HAVE_DLOPEN@ CWDEBUG_DLOPEN_DEFINED
#endif

#endif // LIBCW_DEBUGGING_DEFS_H
